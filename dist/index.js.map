{"version":3,"sources":["../src/container.ts","../src/plugins.ts","../src/bootstrap.ts"],"sourcesContent":["// src/container.ts\ntype Factory<T> = () => T;\nexport type Token<T> = symbol & { __type?: T };\n\ntype Provider<T> =\n  | { kind: 'value'; value: T }\n  | { kind: 'singleton'; factory: Factory<T>; instance?: T }\n  | { kind: 'factory'; factory: Factory<T> };\n\nexport class Container {\n  private registry = new Map<Token<any>, Provider<any>>();\n  constructor(private parent?: Container) {}\n\n  defineToken<T>(desc: string): Token<T> {\n    return Symbol.for(`ioc:${desc}`) as Token<T>;\n  }\n\n  registerValue<T>(token: Token<T>, value: T) {\n    this.registry.set(token, { kind: 'value', value });\n  }\n  registerSingleton<T>(token: Token<T>, factory: Factory<T>) {\n    this.registry.set(token, { kind: 'singleton', factory });\n  }\n  registerFactory<T>(token: Token<T>, factory: Factory<T>) {\n    this.registry.set(token, { kind: 'factory', factory });\n  }\n\n  isRegistered<T>(token: Token<T>): boolean {\n    return this.registry.has(token) || (!!this.parent && this.parent.isRegistered(token));\n  }\n\n  resolve<T>(token: Token<T>): T {\n    if (this.registry.has(token)) {\n      const prov = this.registry.get(token)!;\n      switch (prov.kind) {\n        case 'value': return prov.value as T;\n        case 'singleton':\n          if (prov.instance === undefined) prov.instance = prov.factory();\n          return prov.instance as T;\n        case 'factory': return prov.factory();\n      }\n    }\n    if (this.parent) return this.parent.resolve(token);\n    throw new Error(`Token not registered: ${String(token)}`);\n  }\n\n  override<T>(token: Token<T>, provider: Provider<T>) {\n    this.registry.set(token, provider);\n  }\n\n  reset(tokens?: Token<any>[]) {\n    if (!tokens) return void this.registry.clear();\n    for (const t of tokens) this.registry.delete(t);\n  }\n\n  createScope(): Container {\n    return new Container(this);\n  }\n\n  overrideValue<T>(token: Token<T>, value: T) { this.override(token, { kind: 'value', value }); }\n  overrideSingleton<T>(token: Token<T>, factory: Factory<T>) { this.override(token, { kind: 'singleton', factory }); }\n  overrideFactory<T>(token: Token<T>, factory: Factory<T>) { this.override(token, { kind: 'factory', factory }); }\n}\n\n// Root container + helpers\nexport const rootContainer = new Container();\nexport const defineToken = <T>(desc: string) => rootContainer.defineToken<T>(desc);\nexport const registerValue = <T>(t: Token<T>, v: T) => rootContainer.registerValue(t, v);\nexport const registerSingleton = <T>(t: Token<T>, f: Factory<T>) => rootContainer.registerSingleton(t, f);\nexport const registerFactory = <T>(t: Token<T>, f: Factory<T>) => rootContainer.registerFactory(t, f);\nexport const resolve = <T>(t: Token<T>) => rootContainer.resolve<T>(t);\nexport const isRegistered = <T>(t: Token<T>) => rootContainer.isRegistered<T>(t);\nexport const reset = (tokens?: Token<any>[]) => rootContainer.reset(tokens);\nexport const createScope = () => rootContainer.createScope();\nexport const overrideValue = <T>(t: Token<T>, v: T) => rootContainer.overrideValue(t, v);\nexport const overrideSingleton = <T>(t: Token<T>, f: Factory<T>) => rootContainer.overrideSingleton(t, f);\nexport const overrideFactory = <T>(t: Token<T>, f: Factory<T>) => rootContainer.overrideFactory(t, f);\n","// src/plugins.ts\nimport type { Container } from './container';\n\nexport type IOCRegistrar = (c: Container) => void;\n\nconst registrars: IOCRegistrar[] = [];\n\nexport function registerIOCPlugin(registrar: IOCRegistrar) {\n  registrars.push(registrar);\n}\n\n/** Apenas leitura (sem expor o array interno) */\nexport function getIOCPlugins(): IOCRegistrar[] {\n  return registrars.slice();\n}\n\n/** Para testes: limpar a lista de registrars */\nexport function _clearIOCPlugins() {\n  registrars.length = 0;\n}\n","// src/bootstrap.ts\nimport { rootContainer } from './container';\nimport { getIOCPlugins } from './plugins';\n\nlet bootstrapped = false;\n\n/**\n * Executa todos os registrars previamente registrados (plugins de módulos).\n * Deve ser chamado uma única vez no início do app.\n */\nexport function bootstrapIOC(): void {\n  if (bootstrapped) return;\n  for (const reg of getIOCPlugins()) {\n    reg(rootContainer);\n  }\n  bootstrapped = true;\n}\n\nexport default bootstrapIOC;\n"],"mappings":"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","names":[]}