{"version":3,"sources":["../src/container.ts","../src/plugins.ts","../src/bootstrap.ts","../src/decorators.ts"],"sourcesContent":["// src/container.ts\ntype Factory<T> = () => T;\nexport type Token<T> = symbol & { __type?: T };\n\ntype Provider<T> =\n  | { kind: 'value'; value: T }\n  | { kind: 'singleton'; factory: Factory<T>; instance?: T }\n  | { kind: 'factory'; factory: Factory<T> };\n\nexport class Container {\n  private registry = new Map<Token<any>, Provider<any>>();\n  constructor(private parent?: Container) {}\n\n  defineToken<T>(desc: string): Token<T> {\n    return Symbol.for(`ioc:${desc}`) as Token<T>;\n  }\n\n  registerValue<T>(token: Token<T>, value: T) {\n    this.registry.set(token, { kind: 'value', value });\n  }\n  registerSingleton<T>(token: Token<T>, factory: Factory<T>) {\n    this.registry.set(token, { kind: 'singleton', factory });\n  }\n  registerFactory<T>(token: Token<T>, factory: Factory<T>) {\n    this.registry.set(token, { kind: 'factory', factory });\n  }\n\n  isRegistered<T>(token: Token<T>): boolean {\n    return this.registry.has(token) || (!!this.parent && this.parent.isRegistered(token));\n  }\n\n  resolve<T>(token: Token<T>): T {\n    if (this.registry.has(token)) {\n      const prov = this.registry.get(token)!;\n      switch (prov.kind) {\n        case 'value': return prov.value as T;\n        case 'singleton':\n          if (prov.instance === undefined) prov.instance = prov.factory();\n          return prov.instance as T;\n        case 'factory': return prov.factory();\n      }\n    }\n    if (this.parent) return this.parent.resolve(token);\n    throw new Error(`Token not registered: ${String(token)}`);\n  }\n\n  override<T>(token: Token<T>, provider: Provider<T>) {\n    this.registry.set(token, provider);\n  }\n\n  reset(tokens?: Token<any>[]) {\n    if (!tokens) return void this.registry.clear();\n    for (const t of tokens) this.registry.delete(t);\n  }\n\n  createScope(): Container {\n    return new Container(this);\n  }\n\n  overrideValue<T>(token: Token<T>, value: T) { this.override(token, { kind: 'value', value }); }\n  overrideSingleton<T>(token: Token<T>, factory: Factory<T>) { this.override(token, { kind: 'singleton', factory }); }\n  overrideFactory<T>(token: Token<T>, factory: Factory<T>) { this.override(token, { kind: 'factory', factory }); }\n}\n\n// Root container + helpers\nexport const rootContainer = new Container();\nexport const defineToken = <T>(desc: string) => rootContainer.defineToken<T>(desc);\nexport const registerValue = <T>(t: Token<T>, v: T) => rootContainer.registerValue(t, v);\nexport const registerSingleton = <T>(t: Token<T>, f: Factory<T>) => rootContainer.registerSingleton(t, f);\nexport const registerFactory = <T>(t: Token<T>, f: Factory<T>) => rootContainer.registerFactory(t, f);\nexport const resolve = <T>(t: Token<T>) => rootContainer.resolve<T>(t);\nexport const isRegistered = <T>(t: Token<T>) => rootContainer.isRegistered<T>(t);\nexport const reset = (tokens?: Token<any>[]) => rootContainer.reset(tokens);\nexport const createScope = () => rootContainer.createScope();\nexport const overrideValue = <T>(t: Token<T>, v: T) => rootContainer.overrideValue(t, v);\nexport const overrideSingleton = <T>(t: Token<T>, f: Factory<T>) => rootContainer.overrideSingleton(t, f);\nexport const overrideFactory = <T>(t: Token<T>, f: Factory<T>) => rootContainer.overrideFactory(t, f);\n","// src/plugins.ts\nimport type { Container } from './container';\n\nexport type IOCRegistrar = (c: Container) => void;\n\nconst registrars: IOCRegistrar[] = [];\n\nexport function registerIOCPlugin(registrar: IOCRegistrar) {\n  registrars.push(registrar);\n}\n\n/** Apenas leitura (sem expor o array interno) */\nexport function getIOCPlugins(): IOCRegistrar[] {\n  return registrars.slice();\n}\n\n/** Para testes: limpar a lista de registrars */\nexport function _clearIOCPlugins() {\n  registrars.length = 0;\n}\n","// src/bootstrap.ts\nimport { rootContainer } from './container';\nimport { getIOCPlugins } from './plugins';\n\nlet bootstrapped = false;\n\n/**\n * Executa todos os registrars previamente registrados (plugins de módulos).\n * Deve ser chamado uma única vez no início do app.\n */\nexport function bootstrapIOC(): void {\n  if (bootstrapped) return;\n  for (const reg of getIOCPlugins()) {\n    reg(rootContainer);\n  }\n  bootstrapped = true;\n}\n\nexport default bootstrapIOC;\n","// src/decorators.ts\nimport { Container, Token, defineToken, rootContainer } from './container';\n\ntype Lifetime = 'singleton' | 'transient';\n\ntype InjectableOptions<T> = {\n  token?: Token<T> | string;\n  lifetime?: Lifetime;\n  container?: Container;\n};\n\n// Guarded access to Reflect metadata so the lib works even without reflect-metadata.\ntype ReflectWithMetadata = typeof Reflect & { getMetadata?: (key: string, target: object) => any };\nconst ReflectMeta = Reflect as ReflectWithMetadata;\n\n// Internal store for constructor parameter tokens provided via @Inject.\nconst paramTokens = new WeakMap<Function, (Token<any> | undefined)[]>();\n\n/**\n * Marca um parâmetro do construtor para ser resolvido a partir de um Token.\n * Use quando o tipo não pode ser deduzido ou para customizar o Token.\n */\nexport function Inject(tokenOrDesc: Token<any> | string): ParameterDecorator {\n  return (target, _propertyKey, index) => {\n    const existing = paramTokens.get(target as unknown as Function) ?? [];\n    const token =\n      typeof tokenOrDesc === 'string'\n        ? defineToken(tokenOrDesc)\n        : tokenOrDesc;\n    existing[index] = token;\n    paramTokens.set(target as unknown as Function, existing);\n  };\n}\n\n/**\n * Resolve os Tokens dos parâmetros do construtor usando:\n * 1) @Inject declarado explicitamente\n * 2) design:paramtypes (se reflect-metadata estiver carregado)\n */\nfunction getConstructorTokens(target: Function): Token<any>[] {\n  const explicit = paramTokens.get(target) ?? [];\n  const designTypes = ReflectMeta.getMetadata?.('design:paramtypes', target) as any[] | undefined;\n  const inferred = designTypes ?? [];\n\n  const max = Math.max(explicit.length, inferred.length);\n  const tokens: Token<any>[] = [];\n\n  for (let i = 0; i < max; i++) {\n    const provided = explicit[i];\n    if (provided) {\n      tokens.push(provided);\n      continue;\n    }\n    const type = inferred[i];\n    if (type && type.name && type.name !== 'Object') {\n      tokens.push(defineToken(type.name));\n      continue;\n    }\n    throw new Error(`Token ausente para o parâmetro ${i} do construtor de ${target.name}. Adicione @Inject().`);\n  }\n\n  return tokens;\n}\n\n/**\n * Registra a classe no container e monta as dependências via construtor.\n *\n * - Por padrão registra como singleton no rootContainer.\n * - Se lifetime === 'transient', registra como factory.\n * - O token padrão é o nome da classe, mas pode ser passado via options.token.\n */\nexport function Injectable<T>(options: InjectableOptions<T> = {}): ClassDecorator {\n  return (ctor: any) => {\n    const container = options.container ?? rootContainer;\n    const token =\n      typeof options.token === 'string'\n        ? defineToken<T>(options.token)\n        : options.token ?? defineToken<T>(ctor.name);\n    const deps = getConstructorTokens(ctor);\n    const factory = () => new ctor(...deps.map((t) => container.resolve(t)));\n\n    if (options.lifetime === 'transient') {\n      container.registerFactory(token, factory);\n    } else {\n      container.registerSingleton(token, factory);\n    }\n  };\n}\n\n/**\n * Injeta uma dependência em um campo usando o rootContainer.\n * Útil para cenários React/Expo em que não queremos mudar o construtor.\n */\nexport function Resolve(tokenOrDesc?: Token<any> | string): PropertyDecorator {\n  return (target, propertyKey) => {\n    const token =\n      tokenOrDesc === undefined\n        ? defineToken(String(propertyKey))\n        : typeof tokenOrDesc === 'string'\n          ? defineToken(tokenOrDesc)\n          : tokenOrDesc;\n\n    Object.defineProperty(target, propertyKey, {\n      get() {\n        return rootContainer.resolve(token);\n      },\n      enumerable: true,\n      configurable: true,\n    });\n  };\n}\n"],"mappings":"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","names":[]}